## 01P - Linux命令基础习惯 - Linux系统编程

### 查看当前可使用的 Shell

使用 `cat /etc/shells` 命令可以查看系统中可用的 shell：

```bash
$ cat /etc/shells
# /etc/shells: valid login shells
/bin/sh
/bin/bash
/bin/rbash
/bin/dash
/bin/zsh
/usr/bin/zsh
```

### 主键盘快捷键

| 功能                  | 快捷键              | 说明                      |
|-----------------------|---------------------|---------------------------|
| 上移                   | `Ctrl + p`          | 向上移动光标               |
| 下移                   | `Ctrl + n`          | 向下移动光标               |
| 左移                   | `Ctrl + b`          | 向左移动光标               |
| 右移                   | `Ctrl + f`          | 向右移动光标               |
| 删除光标后的字符       | `Ctrl + d`          | 删除光标后的字符           |
| 移动到行首             | `Ctrl + a`          | 移动到当前行的第一个字母   |
| 移动到行尾             | `Ctrl + e`          | 移动到当前行的末尾         |
| 删除光标前的单个字符   | `Backspace`         | 删除光标前的单个字符       |
| 清除整行               | `Ctrl + u`          | 清除当前行所有内容         |
| 删除光标到行末         | `Ctrl + k`          | 删除光标到行末的内容       |
| 向上滚动显示           | `Shift + PgUp`      | 查看终端上方内容           |
| 向下滚动显示           | `Shift + PgDn`      | 查看终端下方内容           |
| 增大终端字体           | `Ctrl + Shift + +`  | 增大终端显示的字体         |
| 减小终端字体           | `Ctrl + -`          | 减小终端显示的字体         |
| 新开一个终端窗口       | `Ctrl + Alt + T`    | 打开新的终端               |
| 清屏                   | `Ctrl + l` 或 `clear` | 清除终端内容显示           |

---

## 02P - 类 Unix 系统目录

### Linux 系统目录简介

| 目录  | 说明                                                  |
|-------|-------------------------------------------------------|
| `bin`   | 存放二进制可执行文件                                 |
| `boot`  | 存放开机启动程序                                     |
| `dev`   | 存放设备文件：字符设备、块设备                        |
| `home`  | 存放普通用户的主目录                                  |
| `etc`   | 存放用户信息和系统配置文件，如 `passwd`、`group`     |
| `lib`   | 存放库文件，例如：`libc.so.6`                        |
| `root`  | 管理员的宿主目录（家目录）                           |
| `usr`   | 用户资源管理目录（Unix Software Resource）           |

### Linux 下的“所见皆文件”概念

在 Linux 系统中，几乎所有内容都被当作文件，包括设备文件。以下是一个示例：鼠标设备文件。

![鼠标设备文件](assets/1630508053759-1d7e0ed4-d370-4491-b244-ddd7a351c986.png)

---

## 03P - 目录和文件操作 1

### Linux 系统文件类型

| 文件类型        | 符号  |
|-----------------|-------|
| 普通文件        | `-`   |
| 目录文件        | `d`   |
| 字符设备文件    | `c`   |
| 块设备文件      | `b`   |
| 软连接          | `l`   |
| 管道文件        | `p`   |
| 套接字          | `s`   |
| 未知文件        | -     |

### 文件权限说明

![文件权限说明](assets/1630508057153-ef275b5b-d2ef-4ae2-85d0-6693029aa9d9.png)

### 目录项详细信息

- **文件权限**：读写执行权限
- **硬链接计数**：文件或目录的链接数量
- **所有者**：文件的拥有者
- **所属组**：文件所属的用户组
- **大小**：文件的大小
- **时间**：最后修改时间
- **文件名/文件夹名**：文件或文件夹的名称

### 权限具体展开

权限格式：`-rw-r--r--`

| 位置 | 含义                               |
|------|------------------------------------|
| 1    | 文件类型                           |
| 2-4  | 所有者读、写、执行权限             |
| 5-7  | 同组用户的读、写、执行权限         |
| 8-10 | 其他用户的读、写、执行权限         |

### `which` 指令

使用 `which` 指令查看命令所在目录位置：

![which指令](assets/1630508057436-1a7fc65e-2da3-442b-b7c4-9f314294f573.png)

### 隐藏终端中的路径

通过修改 `.bashrc` 文件来隐藏终端中的路径：

```bash
vi ~/.bashrc
```

在文件末尾添加：

```bash
PS1=$
```

保存并退出，重启终端即可：

![隐藏终端路径效果](assets/1630508057976-18ffeae7-f785-4137-8442-99a6495ce9ba.png)

### 目录复制

- `cp -a dirname1 dirname2`：复制目录1及其下所有文件到目录2，保持文件权限和改动时间。
- `cp -r dirname1 dirname2`：递归复制目录1到目录2。

![目录复制](assets/1630508060090-35d1c427-c5c7-49fb-9a5a-987ad4f56ced.png)

**区别**：`-a` 是完全复制，包括文件权限和修改时间等；`-r` 是递归复制，不保证文件权限等一致。



## 04P - 目录和文件操作 2

### 查看文件内容

- `more filename`  
  与 `cat` 类似，但适用于大文件查看。
  - **操作**：空格翻页，回车一行。
  - **退出**：用 `q` 或 `Ctrl + c`。

- `less filename`  
  也与 `cat` 类似，支持向前和向后翻页。
  - **操作**：空格翻页，回车一行。
  - **退出**：用 `q` 或 `Ctrl + c`。

- `head -n filename`  
  查看文件的前 n 行。
  - **说明**：不加 `-n` 参数默认查看 10 行。

- `tail -n filename`  
  查看文件的后 n 行。
  - **说明**：默认查看 10 行，顺序显示，而不是倒序显示。

- `tree`  
  查看当前目录结构树（需安装 `tree` 命令）。

---

## 05P - 软链接和硬链接

- `ln -s file file.s`  
  创建一个软链接，类似于 Windows 下的快捷方式。

  ![](assets/1631073340327-ffdbede1-46f6-4836-83bb-7570aa7155ad.png)

  - **说明**：软链接的大小是文件路径的大小。

  - **注意**：相对路径创建的软链接移动后会失效，建议使用绝对路径创建。软链接的权限指的是其本身的权限，而不是指向文件的权限。

- `ln file file.h`  
  创建一个硬链接。创建后，文件的硬链接计数 +1。

  ![](assets/1631078962606-a60c96cb-9528-4034-91b2-d38c052d1120.png)

  - **说明**：文件和硬链接的 Inode 是相同的，修改操作会同步反映在所有链接上。

  - **删除**：当删除一个硬链接时，硬链接计数 -1，计数减为 0 时文件才会被删除。

---

## 06P - 创建和修改用户及用户组

- `whoami`  
  查看当前用户。

- `chmod`  
  修改权限操作。

  ### 第一种：文字设定法
  ```bash
  chmod [who] [+|-|=] [mode] filename
  ```

  - **操作对象** `who`：
    - `u`：用户（文件或目录的所有者）。
    - `g`：同组用户（与文件所有者有相同组 ID 的用户）。
    - `o`：其他用户。
    - `a`：所有用户（系统默认值）。

  - **操作符号**：
    - `+`：添加某个权限。
    - `-`：取消某个权限。
    - `=`：赋予给定权限并取消其他所有权限。

  ### 第二种：数字设定法
  ```bash
  chmod 操作码 filename
  ```

  - **示例**：对于 `file2` 的权限 `-rw-rw-r--`：
    - 三个组的权限用二进制编号。
    - 设置当前用户对文件的读、写、执行权限：`4（读）+ 2（写）+ 1（执行） = 7`。

  - **权限设置示例**：
    - 所有者：`rwx = 7`
    - 所有者所在组：`rw = 6`
    - 其他用户：`r = 4`
    - **操作码**：764

## 07P - find 命令 1

### `find` 命令：找文件

- `-type`：按文件类型搜索  
  - `d`：目录  
  - `p`：管道  
  - `s`：套接字  
  - `c`：字符设备  
  - `b`：块设备  
  - `l`：软链接  
  - `f`：普通文件  

- `-name`：按文件名搜索  
  ```bash
  find ./ -name "*file*.jpg"
  ```

- `-maxdepth`：指定搜索深度，应作为第一个参数出现。  
  ```bash
  find ./ -maxdepth 1 -name "*file*.jpg"
  ```

- `-size`：按文件大小搜索，单位为 k、M、G  
  ```bash
  find /home/itcast -size +20M -size -50M
  ```

- `-atime`、`-mtime`、`-ctime`：按天搜索，`amin`、`mmin`、`cmin`：按分钟搜索。  
  - `-atime`：最近访问时间  
  - `-mtime`：最近更改时间（文件属性）  
  - `-ctime`：最近改动时间（文件内容）  

- `-exec`：将 `find` 搜索的结果集执行某一指定命令  
  ```bash
  find /usr/ -name '*tmp*' -exec ls -ld {} \;
  ```

- `-ok`：以交互式的方式执行指定命令  

- `-xargs`：将 `find` 搜索的结果集执行某一指定命令，当结果集数量过大时，可以分片映射。  
  ```bash
  find /usr/ -name '*tmp*' | xargs ls -ld
  ```

- `-print0`：使用 `null` 字符分隔输出。  
  ```bash
  find /usr/ -name '*tmp*' -print0 | xargs -0 ls -ld
  ```

---

## 08P - 午后复习

---

## 09P - find 命令 2

### `-exec` 示例

将 `find` 搜索的结果集执行某一指定命令。  
```bash
find /usr/ -name '*tmp*' -exec ls -ld {} \;
```

![find -exec 示例](assets/1630508073667-4d53ae9a-dd12-4192-8e42-4e91fffa3d55.png)

### `-ok` 示例

以交互式的方式将 `find` 搜索的结果集执行某一指定命令。

![find -ok 示例](assets/1630508073971-9c537c29-9288-4f2b-aca3-2aa20d1d59a9.png)


## 10P - grep 和 xargs

### `grep` 命令：找文件内容

```bash
grep -r 'copy' ./ -n
```
- `-n` 参数：显示行号

---

### `ps` 监控后台进程工作情况

默认只显示当前可以和用户交互的进程。

```bash
ps aux | grep 'cupsd'  # 检索进程结果集。
```

下图显示和内核相关进程：

![进程监控](assets/1630508074765-13709755-d1e9-4819-a105-21ebff745367.png)

使用 `grep` 搜索进程，有一条结果是搜索进程本身。

---

### `find … | xargs ls -l`

对 `find` 操作的结果集进行操作，等价于：

```bash
find … -exec ls -l {} \;
```

两者的差别在于，当结果集合很大时，`xargs` 会对结果进行分段处理，所以性能更好。

![find与xargs对比](assets/1631080505786-1e6cd36f-111a-4634-b4ea-fd8ff03839b3.png)

---

### `xargs` 使用注意事项

创建名字带空格的文件的方法：
- 第一个方法：文件名加引号
- 第二个方法：转义

但 `xargs` 也有缺陷，默认用空格来分割结果集，当文件名有空格的时候，会因为文件名被切割失效。

![xargs缺陷演示](assets/1630508074980-2ee210b5-f1d6-4200-a6e6-737fa10d96e8.png)

### 解决 `xargs` 的缺陷

指定切分符号为 null：

```bash
find /usr/ -name '*tmp*' -print0 | xargs -0 ls -l
```

第一个 `-print0` 指定结果集分隔为 null，第二个 `-0` 指定 `xargs` 分隔为 null。

![解决xargs缺陷](assets/1630508076505-9dfd7102-ed2c-4b5c-8409-b04a323f4da0.png)

---

## 11P - xargs 加强和 awk 说明

---

## 12P - 软件包安装

![软件包安装](assets/1631081618506-11ccc31e-4940-42ef-84e5-fa42bf9723b1.png)

使用安装包进行软件安装。

![软件安装示例](assets/1630508078066-1f942d63-fbeb-42b3-b72c-f32d43009c26.png)

---

## 13P - 压缩命令 gzip 和 bzip2

这两个压缩工具的缺陷是只能对单个文件进行压缩，不能压目录，也不能打包。

![压缩命令对比](assets/1631084261950-485433f5-ac02-4259-9d57-af72ef4fcfbe.png)

### `tar` 压缩命令：

1. 使用 `gzip` 压缩：
   ```bash
   tar -zcvf test.tar.gz file1 dir2
   ```

2. 使用 `bzip2` 压缩：
   ```bash
   tar -jcvf test.tar.bz2 file1 dir2
   ```

### `tar` 解压命令：

将压缩命令中的 `c` 改为 `x`：

1. 使用 `gzip` 解压：
   ```bash
   tar zxvf test.tar.gz
   ```

2. 使用 `bzip2` 解压：
   ```bash
   tar jxvf test.tar.bz2
   ```

---

### `tar zcvf` 参数说明：

- `z`：压缩
- `c`：创建
- `v`：显示压缩过程（可去掉）
- `f`：指定文件

---

### `file filename` 命令

文件照妖镜：

![file命令示例](assets/1630508079999-7c0517cf-9ef1-4a23-ac13-396b447d9e49.png)

## 14P - RAR 压缩和 ZIP 压缩

### RAR 压缩

- **压缩命令**：
  ```bash
  rar a -r newdir dir
  ```
  将 `dir` 目录压缩成 `newdir.rar`。如果压缩材料里没有目录，`-r` 参数可以省去。

- **解压命令**：
  ```bash
  unrar x newdir.rar
  ```

- **查看软件安装信息**：
  ```bash
  sudo aptitude show softname
  ```
  ![](assets/1630508083147-8c0c2ddf-bebb-4d5d-b03f-4d6484b8d044.png)

### ZIP 压缩

- **压缩命令**：
  ```bash
  zip -r dir.zip dir
  ```

- **解压命令**：
  ```bash
  unzip dir.zip
  ```

ZIP 文件在 Windows 和 Linux 下通用。

---

## 15P - 其他命令

- **查看当前在线用户**：
  ```bash
  who
  ```

- **查看当前用户**（不带有进程）：
  ```bash
  whoami
  ```

- **查看当前运行的用户作业**：
  ```bash
  jobs
  ```

- **查看环境变量**：
  ```bash
  env
  ```
  ![](assets/1630508085634-387a574d-bca5-4005-b8a6-9410a58ba4b2.png)

- **任务管理器**（文字版）：
  ```bash
  top
  ```
  ![](assets/1631083114455-a547ecaf-c7a5-402e-bbc1-92a5644bca1e.png)

- **设置文件掩码**：
  ```bash
  umask
  ```
  ![](assets/1631083394738-effeb023-7411-4244-9fe3-18ac54d3a531.png)

- **查看网卡信息**：
  ```bash
  ifconfig
  ```
  ![](assets/1630508086669-3c8470a7-5052-4d05-bd05-b4ced0205e9b.png)

---

## 16P - 总结

---

## 17P - 复习

创建一个目录，大小默认是 4096K。

## 二

### 18P - Vim 的三种工作模式

![](assets/1630539326204-aef863f9-faaf-407c-ad53-f62c28408c01.png)

---

### 19P - Vim 基本操作 - 跳转和删字符

- **进入编辑模式**：
  - `i`：光标前插入字符
  - `I`：光标所在行的行首插入
  - `a`：光标后插入字符
  - `A`：光标所在行的行末插入字符
  - `o`：光标所在行的下一行插入
  - `O`：光标所在行的上一行插入字符
  - `s`：删除光标所在字符并进入编辑模式
  - `S`：删除光标所在行并进入编辑模式

- **删除字符和单词**：
  - `x`：删除光标所在字符，工作模式不变
  - `dw`：删除光标所在单词，要求光标在首字母上
  - `D`：删除光标所在位置到行末，工作模式不变
  - `0`：光标移到行首，工作模式不变
  - `$`：光标移到行尾，工作模式不变
  - `d0`：删除光标所在位置到行首，工作模式不变
  - `d$`：删除光标所在位置到行末，工作模式不变

- **命令模式下行跳转**：
  - `line-G`：缺点是没有回显
  - `:line` + 回车：末行模式下行跳转
  - `gg`：跳转首行
  - `G`：跳转末行
  - `gg=G`：无回显
  - `%`：光标处于左大括号时，使用 `%` 跳转到对应右大括号，再按 `%` 跳回去

- **自动缩进设置**：
  在 `vimrc` 中添加以下内容（默认自动缩进为 8 个空格）：
  ```bash
  set tabstop=4    # 设置制表符宽度为 4
  set softtabstop=4 # 设置软制表符宽度为 4
  set shiftwidth=4  # 设置缩进空格数为 4
  ```

---

### 20P - Vim 基本操作 - 删除

- **替换单个字符**：
  - `r`：命令模式下替换光标选中字符。

- **删除指定区域**：
  1. 光标选中要删除的首字符，按 `v` 进入可视模式。
  2. 使用 `hjkl` 移动到要删除的末尾，按 `d` 删除。

- **删除整行**：
  - `dd`：删除光标所在行。
  - `n + dd`：删除从光标开始的 n 行。

---

### 21P - Vim 基本操作 - 复制粘贴

- **复制和粘贴命令**：
  - `yy`：复制光标所在行。
  - `小p`：向后粘贴剪切板内容，粘贴在光标所在位置的下一行。
  - `大P`：向前粘贴剪切板内容，粘贴在光标所在位置的上一行。

注意：`dd` 不是删除，而是剪切，内容去了剪切板而不是删除。

- **复制多行**：
  - `n-yy`：复制光标所在位置的 n 行，包括光标所在行。

---

### 22P - Vim 基本操作 - 查找和替换

- **查找命令**：
  - `/ + findname`：命令模式下查找。
  - 按回车后，按 `n` 找下一个，`N` 跳到上一个。
  - 查找光标所在单词：光标在目标单词上时，使用 `*` 或 `#` 查找下一个。

- **替换命令**（在末行模式下进行）：
  - **单行替换**：
    ```bash
    :s /待替换词/替换词
    ```
  - **全文替换**：
    ```bash
    :%s /待替换词/替换词   # 默认替换每行的首个
    :%s /待替换词/替换词/g # 真正意义上的全局替换
    ```
  - **区域替换**：
    ```bash
    :24,35s /待替换词/替换词/g # 替换 24-35 行之间的目标词
    ```

- **末行模式下历史命令**：
  - `Ctrl-p`：上一条命令
  - `Ctrl-n`：下一条命令



## 23P - Vim 基本操作 - 其他

- **命令模式下的撤销和反撤销**：
  - `u`：撤销操作
  - `Ctrl-r`：反撤销操作

- **分屏操作**：
  - `:sp`：水平分屏
  - `:vsp`：竖直分屏
  - `:sp filename` 或 `:vsp filename`：分屏并打开指定文件
  - `Ctrl-w w`：切换分屏
  - `:q`：退出当前窗口
  - `:qall`：退出所有窗口

- **查看 manpage**：
  - 在命令模式下，将光标放在待查看的单词上，按 `K` 查看第一卷
  - `n + K`：查看第 n 卷

- **查看宏定义**：
  - 将光标放在待查看的词上，按 `[` + `d` 查看

- **使用 shell 命令**：
  - 在末行模式下输入 `:! + 命令`
  - 执行后会切换至终端显示结果，按 Enter 返回 Vim 界面

![](assets/1630508089475-da654f0c-ae2b-41dd-883e-707e69168a13.png)

---

## 24P - Vim 配置思路

- **Vim 配置文件**：
  1. `/etc/vim/vimrc`：系统级配置文件
  2. `~/.vimrc`：用户级配置文件，优先加载

---

## 25P - GCC 编译四步骤

![](assets/1630539595971-7be3c275-25a2-43a4-9b83-98b64dc3947b.png)

---

## 26P - GCC 编译常用参数

- **编译命令示例**：
  ```bash
  gcc -I ./hellodir hello.c -o hello
  ```

- **常用参数说明**：
  - `-I`：指定头文件所在目录位置
  - `-c`：只做预处理、编译和汇编，得到二进制文件
  - `-g`：编译时添加调试信息，用于 gdb 调试
  - `-Wall`：显示所有警告信息
  - `-D`：动态注册宏定义
  - `-l`：指定动态库库名
  - `-L`：指定动态库路径

![](assets/1630508091141-5ae44f5a-eb53-4d86-a3c4-ea3da712de06.png)

---

## 27P - 午后复习

---

## 28P - 动态库和静态库理论对比

- **静态库**：
  - 在文件中静态展开，多个文件会多次展开，占用更多内存（例如 100MB 的库展开 100 次则占用 1GB）。
  - 加载速度快。

- **动态库**：
  - 只需加载一次，多个文件共享同一个动态库，节省内存。
  - 加载速度稍慢，但更高效。

![](assets/1630508091594-0e96a592-c2f7-42ab-b6a5-329e084dfbcc.png)

---

## 29P - 静态库制作与使用

- **静态库命名规则**：
  - 名称以 `lib` 开头，以 `.a` 结尾（例如：`libmylib.a`）。

- **制作静态库步骤**：
  1. 将 `.c` 文件编译成 `.o` 文件：
     ```bash
     gcc -c add.c -o add.o
     ```
  2. 使用 `ar` 工具制作静态库：
     ```bash
     ar rcs lib库名.a add.o sub.o div.o
     ```
  3. 编译静态库到可执行文件中：
     ```bash
     gcc test.c lib库名.a -o a.out
     ```

![](assets/1631089179227-8f3e1a2c-97c9-453d-aedf-7765c527d042.png)

![](assets/1631089202973-bf55ed54-b891-438f-8d01-de87a9ad4133.png)

---

## 30P - 静态库使用及头文件对应

- **警告处理**：
  编译器只能隐式声明返回值为 `int` 的函数形式，如果函数返回值不是 `int`，则会报错。

- **在 `test.c` 中加入函数声明**：

![](assets/1630508093704-fe36441a-8389-4f74-b9a1-3395fe0ccf93.png)

- **再编译**：
  再次编译后不会报错：

![](assets/1630508094059-23b584ec-9106-4dbe-bc6c-989b6d4d9b4b.png)

- **使用头文件**：
  使用头文件来加载静态库：

![](assets/1630508094356-c2be6922-1c8f-4937-9f37-129c0b7ce0f0.png)

  - 左边的 `define` 为头文件守卫，防止多次 `include` 造成额外开销。

- **无错误且更科学的做法**：

![](assets/1630508094722-28225179-edfe-45c0-bd61-da4473bd6f66.png)

- **将静态库和头文件放至其他目录**：

运行过程如下：

![](assets/1631089956787-11bb6300-6b5b-4f03-9069-158b4ea638d5.png)

---

## 31P - 动态库制作 - 生成与位置无关代码
![](assets/1630508095297-81589af4-af1e-4136-8699-f66218187e5b.png)
- **动态库函数定位**：
  - 写在源代码里的函数，相对 `main` 函数的偏移是固定的。
  - 在链接时，回填 `main` 函数地址，其他函数得到相应的地址。
  - 动态库里的函数使用 `@plt` 标识，动态库加载时会将地址替换。





## 32P - 动态库制作 - 演示

### 制作动态库的步骤

1. **生成位置无关的 .o 文件**：
   ```bash
   gcc -c add.c -o add.o -fPIC
   ```
   使用 `-fPIC` 参数生成的位置无关的代码，便于动态绑定。

2. **使用 gcc -shared 制作动态库**：
   ```bash
   gcc -shared -o lib库名.so add.o sub.o div.o
   ```

3. **编译可执行程序时指定动态库**：
   - `-l`：指定库名
   - `-L`：指定库路径
   ```bash
   gcc test.c -o a.out -l mymath -L ./lib
   ```

4. **运行可执行程序**：
   ```bash
   ./a.out
   ```

### 过程演示：

- **步骤一：生成位置无关的 .o 文件**  
  ![](assets/1630508095757-9a8c63c2-a4d1-47d8-8884-843147689adb.png)

- **步骤二：制作动态库**  
  ![](assets/1630508096135-4df57bf5-1747-483e-b45a-0c6deaed6f5b.png)

- **步骤三：编译程序**  
  文件分布如下：动态库在 `lib` 目录下，头文件在 `inc` 目录下  
  ![](assets/1630508096428-803faac2-189a-4111-a278-b665205cf0f0.png)

  编译命令：  
  ![](assets/1630508096863-c9e73553-3527-41e8-913d-0df5c2e0fba2.png)

- **步骤四：执行文件，出错**  
  ![](assets/1630508097195-ee5f9625-6536-4d11-afe3-19e139714fb6.png)

---

## 33P - 动态库加载错误原因及解决方式

### 出错原因分析

- **连接器**：在链接阶段工作，需要 `-l` 和 `-L` 参数。
- **动态链接器**：在程序运行阶段工作，需要提供动态库所在目录。

### 解决方案

- **指定动态库路径并使其生效**：通过环境变量指定动态库所在位置：
  ```bash
  export LD_LIBRARY_PATH=动态库路径
  ```

- 当关闭终端，再次执行 `a.out` 时又报错。这是因为环境变量是进程的概念，关闭终端后再打开是两个不同的进程，环境变量发生变化。

- 要使环境变量永久生效，需要修改 Bash 配置文件：
  ```bash
  vi ~/.bashrc
  ```

- 修改后立即生效：
  ```bash
  . ~/.bashrc  # 或者使用 source .bashrc
  ```

- 重新执行 `a.out`，就不会报错了。

---

## 34P - 动态库加载错误原因及解决方式 2

### 解决方式：

1. **通过环境变量**：
   ```bash
   export LD_LIBRARY_PATH=动态库路径
   ```
   然后运行 `./a.out` 成功！(临时生效，终端重启后失效)

2. **永久生效**：
   - 打开终端配置文件：
     ```bash
     vi ~/.bashrc
     ```
   - 写入：
     ```bash
     export LD_LIBRARY_PATH=动态库路径
     ```
   - 保存并执行：
     ```bash
     . ~/.bashrc  # 或者 source .bashrc
     ```
   - 运行 `./a.out` 成功！

3. **拷贝自定义动态库到 `/lib`** (标准 C 库所在目录位置)。

4. **配置文件法**：
   1. 编辑配置文件：
      ```bash
      sudo vi /etc/ld.so.conf
      ```
   2. 写入动态库绝对路径，保存。
   3. 使配置文件生效：
      ```bash
      sudo ldconfig -v
      ```
   4. 运行 `./a.out` 成功！使用 `ldd a.out` 查看。

---

## 35P - 扩展讲解 - 数据段合并

![](assets/1630508097866-2cab3a87-b24e-4b11-b3a3-7448b32c3a44.png)

---

## 36P - 总结

---

## 37P - 复习



## 38P - gdb 调试基础指令

使用 gdb 调试工具之前，需要在编译时增加 `-g` 参数。添加此参数后，生成的可执行文件会包含调试信息，从而使其在调试时更具可读性。

### 基础指令

1. **编译带调试信息的程序**：
   ```bash
   gcc gdbtest.c -o a.out -g
   ```

2. **启动 gdb 调试**：
   ```bash
   gdb ./a.out
   ```

3. **列出源代码**：
   - 显示源代码的某一部分：
     ```bash
     list
     list 1  # 从第1行开始显示源代码
     ```

4. **设置断点**：
   - 在指定行设置断点：
     ```bash
     b 20  # 在第20行设置断点
     ```

5. **运行程序**：
   ```bash
   run    # 或者使用 r
   ```

6. **逐行执行指令**：
   - **下一条指令（越过函数）**：
     ```bash
     n  # 或者使用 next
     ```
   - **进入函数**：
     ```bash
     s  # 或者使用 step
     ```

7. **查看变量值**：
   ```bash
   p i  # 查看变量 i 的值
   ```

8. **继续执行**：
   ```bash
   continue  # 继续执行至下一个断点
   ```

9. **结束当前函数调用**：
   ```bash
   finish  # 返回到调用函数的上下文
   ```

10. **退出 gdb**：
    ```bash
    quit  # 退出 gdb 调试
    ```

### 示例操作

- **启动调试**：
  ![](assets/1630508098254-a7c1a9e7-6d8f-4d8c-ae68-5599b93ac88f.png)

- **列出代码**：
  ![](assets/1630508098585-3943a4d5-5624-4b48-ba0f-fc073fe18215.png)

- **设置断点**：
  ![](assets/1630508098903-573966e8-35ab-4b6f-90e7-32eef85befdf.png)

- **运行程序**：
  ![](assets/1630508099363-5ac60efb-3eea-4ce7-830e-c6a538de6597.png)

- **继续执行**：
  使用 `next` 或 `step` 执行接下来的指令：
  - 使用 `next`：
    ![](assets/1630508099641-ccc54278-db7e-4c31-afec-e30144d74709.png)

  - 使用 `until` 退出系统函数：
    ![](assets/1630508100321-6f911360-599c-4f43-a0d0-25b9494b7aa4.png)

- **查看变量值**：
  ![](assets/1630508100584-d7b040e3-c9e9-43e6-8750-4ded6c7416b1.png)

- **继续执行到结束**：
  ![](assets/1630508100981-9b78c268-2317-4372-b77b-1e73658022eb.png)

这些指令构成了使用 gdb 进行基础调试的核心操作，可以帮助开发者快速定位和修复代码中的错误。


## 39P - gdb 调试其他指令

在使用 gdb 进行调试时，还有一些其他有用的指令：

### 其他指令

1. **查找段错误出现位置**：
   ```bash
   run  # 使用 run 查找段错误的位置
   ```

2. **设置 main 函数的命令行参数**：
   - 在 `start` 或 `run` 之前使用：
     ```bash
     set args 字串1 字串2 ...
     ```

3. **查看断点信息**：
   ```bash
   info b  # 查看当前的断点信息
   ```

4. **设置条件断点**：
   ```bash
   b 20 if i == 5  # 在第20行设置条件断点，当 i 等于 5 时触发
   ```

5. **查看变量类型**：
   ```bash
   ptype 变量名  # 查看变量的类型
   ```

6. **列出当前程序的栈帧**：
   ```bash
   bt  # 列出当前程序存活的栈帧
   ```

7. **根据栈帧编号切换栈帧**：
   ```bash
   frame 编号  # 切换到指定编号的栈帧
   ```

8. **设置跟踪变量**：
   ```bash
   display 变量名  # 设置跟踪变量
   ```

9. **取消设置跟踪变量**：
   ```bash
   undisplay 编号  # 使用跟踪变量的编号取消跟踪
   ```

![](assets/1631106765084-8ac23495-2945-451d-89ab-422b1f425e54.png)

---

## 40P - gdb 常见错误说明

1. **没有符号被读取**：
   - 这是因为在编译时没有加 `-g` 参数。
   - 解决方法：在 gdb 中使用 `file` 命令加载带 `-g` 编译的文件，可以在不退出 gdb 的情况下直接读取调试信息。

---

## 41P - makefile 基础规则

`makefile` 是管理项目构建的文件。它有两个命名方式：`makefile` 或 `Makefile`，都可以通过 `make` 命令使用。

### 规则、函数和自动变量

1. **一个规则**：
   ```
   目标: 依赖条件
    (一个 tab 缩进) 命令
   ```
   例如：
   ```makefile
   hello: hello.c
    gcc hello.c -o hello
   ```

2. **规则的逻辑**：
   - 目标的时间必须晚于依赖条件的时间，否则，目标会被更新。
   - 如果依赖条件不存在，会寻找新的规则生成依赖条件。

3. **示例**：
   ```makefile
   hello: hello.o
    gcc hello.o -o hello
   hello.o: hello.c
    gcc -c hello.c -o hello.o
   ```

4. **执行 `make` 指令**：
   ![](assets/1630508101658-b00a8b07-dd04-47e7-864f-f4c147d5c6c8.png)

5. **运行可执行文件**：
   ![](assets/1630508102019-b405d3db-8d96-4327-ae7e-b3b4555dea4b.png)

---

## 42P - makefile 的一个规则

### 修改源文件并编写 makefile

假设我们修改了 `hello.c`，并且需要进行多文件联合编译。下面是可能的 makefile 示例：

```makefile
all: hello

hello: hello.o add.o sub.o
    gcc hello.o add.o sub.o -o hello

hello.o: hello.c
    gcc -c hello.c -o hello.o

add.o: add.c
    gcc -c add.c -o add.o

sub.o: sub.c
    gcc -c sub.c -o sub.o
```

### 执行结果

- 执行 `make` 指令后，能够看到生成的可执行文件。
- 之后如果修改 `add.c`，使用 `make` 指令会发现所有文件都重新编译了。

### 解决方案

为了避免不必要的重新编译，可以将 makefile 改写为使用依赖关系的方式。

### 修改后的 makefile 示例

```makefile
all: hello

hello: hello.o add.o sub.o
    gcc hello.o add.o sub.o -o hello

%.o: %.c
    gcc -c $< -o $@
```

### 通过时间戳原理进行检测

- `make` 会检查文件的修改时间，如果目标文件的时间早于依赖文件的时间，则会重新编译。

### 指定目标的 makefile

为了确保某个目标是终极目标，可以使用 `ALL` 来明确指定：

```makefile
ALL: hello

hello: hello.o add.o sub.o
    gcc hello.o add.o sub.o -o hello
```

通过这些基础规则和概念，使用 `makefile` 可以更高效地管理和构建 C 项目。





## 43P - 午后回顾

在这部分中，我们回顾了之前学习的内容，包括 gdb 调试指令和 makefile 的基本用法与规则。通过这些学习，我们对调试和构建 C/C++ 项目有了更深入的理解。

---

## 44P - makefile 两个函数和 clean

### makefile 函数

1. **`src = $(wildcard *.c)`**  
   - 此命令会匹配当前目录下的所有 `.c` 文件，并将其文件名组成列表赋值给变量 `src`。这样可以动态地获取所有源文件。

2. **`obj = $(patsubst %.c, %.o, $(src))`**  
   - 此命令将 `src` 中所有后缀为 `.c` 的文件替换为对应的 `.o` 文件，形成 `obj` 变量。这样可以自动管理目标文件的生成。

### `clean` 部分

- `clean` 目标用于清理编译过程中生成的文件，通常包括 `.o` 文件和可执行文件。
  
```makefile
clean:
    rm -f $(obj) hello
```
- 使用 `-` 前缀，表示即使删除文件时出错，仍然继续执行后续命令。如果没有这个 `-`，当尝试删除一个不存在的文件时，会报错并停止执行。

### 模拟执行 `clean`

如果没有文件变动，`a.out` 的时间戳会晚于所有依赖文件，这时 `make` 不会执行任何操作。为了确保可以执行清理操作，可以先模拟执行 `clean` 部分：

```bash
make clean
```

---

## 45P - makefile 3 个自动变量和模式规则

### 3 个自动变量

1. **`$@`**：表示规则中的目标。
2. **`$<`**：表示规则中第一个依赖文件，用于模式规则时，可以依次取出依赖列表中的文件。
3. **`$^`**：表示规则中所有的依赖文件，以空格分隔，并且去除重复项。

### 使用自动变量修改 makefile

为了提高可扩展性，我们可以使用自动变量来简化 makefile，例如：

```makefile
%.o: %.c
    gcc -c $< -o $@
```

这样，每当需要生成 `.o` 文件时，会自动调用对应的 `.c` 文件进行编译。

### 静态模式规则

可以进一步使用静态模式规则来指定特定的目标。例如：

```makefile
$(obj): %.o: %.c
    gcc -c $< -o $@
```

这样定义后，`make` 将会知道如何为 `obj` 中的每个 `.o` 文件生成相应的 `.c` 文件。

### 伪目标

为了解决文件名冲突的问题，可以添加伪目标：

```makefile
.PHONY: clean ALL
```

这行代码可以确保 `make clean` 和 `make ALL` 正确执行，而不受同名文件的影响。

### 编译参数

可以在 makefile 中集中管理编译参数，例如：

```makefile
CFLAGS = -g -Wall
```

---

## 46P - 习题和作业

### 任务要求

1. **文件结构**：
   - 源代码 (`add.c`, `sub.c`) 放在 `src` 目录下。
   - `.o` 文件放在 `obj` 目录下。
   - 头文件 `head.h` 放在 `inc` 目录下。

2. **修改 `hello.c`**：
   - 将 `hello.c` 中的头文件引用调整为引用 `inc` 目录中的头文件。

3. **编写 makefile**：
   - 确保 makefile 能正确处理文件路径和依赖关系。可以使用 `%` 模式规则来匹配文件名。

4. **清理操作**：
   - 使用 `make clean` 来删除生成的文件。

5. **自定义 makefile 名称**：
   - 如果将 makefile 命名为 `m6`，则可以通过 `make -f m6` 来执行。

### 示例 makefile

```makefile
CFLAGS = -g -Wall
SRC = $(wildcard src/*.c)
OBJ = $(patsubst src/%.c, obj/%.o, $(SRC))
INC = -Iinc

all: hello

hello: $(OBJ)
    gcc $(OBJ) -o hello $(CFLAGS)

obj/%.o: src/%.c
    gcc $(CFLAGS) $(INC) -c $< -o $@

clean:
    rm -f obj/*.o hello

.PHONY: clean all
```

通过以上内容，可以有效地管理 C/C++ 项目的构建流程，提高开发效率和可维护性。
